{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"grid-fit Documentation","text":""},{"location":"#installation","title":"Installation","text":""},{"location":"#python","title":"Python","text":"<p>Install directly from GitHub:</p> <pre><code>python -m pip install git+https://github.com/rae-gh/grid-fit.git\n</code></pre>"},{"location":"#r","title":"R","text":"<p>Install directly from GitHub using devtools:</p> <pre><code>install.packages(\"devtools\")\nlibrary(devtools)\ninstall_url(\"https://github.com/rae-gh/grid-fit/archive/refs/heads/main.zip\")\n</code></pre>"},{"location":"#usage-example","title":"Usage Example","text":""},{"location":"#python_1","title":"Python","text":"<pre><code>import gridfit\n# Interpolate between 0 and 1 with 1 interval\nresult = gridfit.interp(0, 1, 1)\nprint(result)  # [0.5]\n</code></pre>"},{"location":"#r_1","title":"R","text":"<pre><code>library(gridfit)\n# Interpolate between 0 and 1 with 1 interval\nresult &lt;- interp(0, 1, 1)\nprint(result)  # [0.5]\n</code></pre> <p>For more details, see the README or source code.</p>"},{"location":"benchmarking/","title":"Benchmarking","text":"<p>This page describes how to benchmark the performance of the grid-fit library against standard Python methods.</p>"},{"location":"benchmarking/#how-to-run-the-benchmark","title":"How to Run the Benchmark","text":"<ol> <li>Make sure you have the required dependencies:</li> <li>numpy</li> <li>scipy</li> </ol> <p>You can install them with:    <pre><code>python -m pip install numpy scipy\n</code></pre></p> <ol> <li> <p>Navigate to the <code>examples/benchmarking/</code> directory.</p> </li> <li> <p>Run the benchmark script:    <pre><code>python benchmark_trilinear.py\n</code></pre></p> </li> </ol> <p>This script compares the performance of the standard Python method (<code>scipy.interpolate.RegularGridInterpolator</code>) with the grid-fit trilinear interpolation (to be implemented). The script will print timing results for each method.</p>"},{"location":"benchmarking/#results","title":"Results","text":"<p>Results are a work in progress. Currently trilinear interpolation itself is a bit faster than scipy but the cosntruction of the grid object so slower:</p> <pre><code>Grid size: 50, Sampled points: 500      Construction:scipy is faster than gridfit by 5.36x      Interpolation:gridfit is faster than scipy by 3.56x\nGrid size: 100, Sampled points: 500     Construction:scipy is faster than gridfit by 141.34x    Interpolation:gridfit is faster than scipy by 6.15x\nGrid size: 200, Sampled points: 500     Construction:scipy is faster than gridfit by 1050.24x   Interpolation:gridfit is faster than scipy by 3.41x\nGrid size: 256, Sampled points: 500     Construction:scipy is faster than gridfit by 3227.74x   Interpolation:gridfit is faster than scipy by 2.19x\nGrid size: 384, Sampled points: 500     Construction:scipy is faster than gridfit by 11688.96x  Interpolation:gridfit is faster than scipy by 3.96x\nGrid size: 50, Sampled points: 1000     Construction:scipy is faster than gridfit by 6.99x      Interpolation:gridfit is faster than scipy by 1.68x\nGrid size: 100, Sampled points: 1000    Construction:scipy is faster than gridfit by 30.23x     Interpolation:gridfit is faster than scipy by 1.49x\nGrid size: 200, Sampled points: 1000    Construction:scipy is faster than gridfit by 685.68x    Interpolation:gridfit is faster than scipy by 1.47x\nGrid size: 256, Sampled points: 1000    Construction:scipy is faster than gridfit by 1646.25x   Interpolation:gridfit is faster than scipy by 1.74x\nGrid size: 384, Sampled points: 1000    Construction:scipy is faster than gridfit by 10000.22x  Interpolation:gridfit is faster than scipy by 3.08x\nGrid size: 50, Sampled points: 10000    Construction:scipy is faster than gridfit by 7.62x      Interpolation:gridfit is faster than scipy by 2.24x\nGrid size: 100, Sampled points: 10000   Construction:scipy is faster than gridfit by 34.32x     Interpolation:gridfit is faster than scipy by 1.54x\nGrid size: 200, Sampled points: 10000   Construction:scipy is faster than gridfit by 546.57x    Interpolation:gridfit is faster than scipy by 1.36x\nGrid size: 256, Sampled points: 10000   Construction:scipy is faster than gridfit by 1315.01x   Interpolation:gridfit is faster than scipy by 2.39x\nGrid size: 384, Sampled points: 10000   Construction:scipy is faster than gridfit by 9893.04x   Interpolation:gridfit is faster than scipy by 1.09x\nGrid size: 50, Sampled points: 100000   Construction:scipy is faster than gridfit by 4.12x      Interpolation:gridfit is faster than scipy by 1.98x\nGrid size: 100, Sampled points: 100000  Construction:scipy is faster than gridfit by 47.77x     Interpolation:gridfit is faster than scipy by 1.57x\nGrid size: 200, Sampled points: 100000  Construction:scipy is faster than gridfit by 274.12x    Interpolation:gridfit is faster than scipy by 1.17x\nGrid size: 256, Sampled points: 100000  Construction:scipy is faster than gridfit by 953.98x    Interpolation:gridfit is faster than scipy by 1.10x\nGrid size: 384, Sampled points: 100000  Construction:scipy is faster than gridfit by 10873.93x  Interpolation:gridfit is faster than scipy by 1.20x\n</code></pre>"},{"location":"bindings/","title":"Bindings: How C++ Compiling Works for Python and R","text":""},{"location":"bindings/#c-core-development","title":"C++ Core Development","text":"<p>You write and edit your C++ code (e.g., in <code>src/</code>).</p>"},{"location":"bindings/#compiling-for-bindings","title":"Compiling for Bindings","text":"<ul> <li>To use your C++ code in Python or R, you must compile it into a shared library (e.g., <code>.so</code> on Linux, <code>.dll</code> on Windows, <code>.dylib</code> on macOS).</li> <li>This is usually done with CMake or a similar build system, which creates the shared library and the necessary binding code (using pybind11 for Python, Rcpp for R).</li> </ul>"},{"location":"bindings/#python-package","title":"Python Package","text":"<ul> <li>The Python package (created with pybind11) includes the compiled shared library (e.g., <code>gridfit.cpython-310-x86_64-linux-gnu.so</code>).</li> <li>When you install the Python package (e.g., with <code>pip install .</code>), the build process compiles the C++ code and places the shared library in the package directory.</li> <li>Python imports this shared library as a module.</li> </ul>"},{"location":"bindings/#r-package","title":"R Package","text":"<ul> <li>The R package (created with Rcpp) also includes the compiled shared library (e.g., <code>gridfit.so</code>).</li> <li>When you build/install the R package (e.g., with <code>devtools::install()</code>), R compiles the C++ code and places the shared library in the package\u2019s <code>libs/</code> directory.</li> <li>R loads this shared library when you load the package.</li> </ul>"},{"location":"bindings/#summary","title":"Summary","text":"<ul> <li>The C++ code is compiled into a shared library for both Python and R.</li> <li>The packages (Python and R) include the compiled version, not the raw C++ source (except for development or source distributions).</li> <li>You need to recompile whenever you change the C++ code and want those changes available in Python or R.</li> </ul>"},{"location":"development/","title":"Development Guide","text":"<p>This page provides instructions for developers working on the grid-fit library.</p>"},{"location":"development/#getting-started-recommended","title":"Getting Started (Recommended)","text":"<ol> <li>Clone the repository: <pre><code>git clone https://github.com/rae-gh/grid-fit.git\ncd grid-fit\n</code></pre></li> <li>(Recommended) Create and activate a conda environment: <pre><code>conda create -n gridfit-dev -c conda-forge python=3.10 cmake make gxx_linux-64 -y\nconda activate gridfit-dev\nconda install -c conda-forge pybind11 pytest numpy scipy -y\nRscript -e 'install.packages(\"devtools\")'\n</code></pre></li> <li>Run the install script: <pre><code>./install.sh\n</code></pre></li> </ol> <p>The <code>install.sh</code> script will: - Clean previous builds - Build the C++ core - Build and install the Python and R bindings - Run example scripts for C++, Python, and R - Print output from all three so you know everything works</p> <p>If you see output from all three languages, your setup is correct!</p>"},{"location":"development/#manual-developer-setup-advanced","title":"Manual Developer Setup (Advanced)","text":"<p>If you want to set up a development environment for editing and testing code, follow these steps:</p> <ol> <li>Clone the repository:    <pre><code>git clone https://github.com/rae-gh/grid-fit.git\ncd grid-fit\n</code></pre></li> <li>(Optional) Create and activate a conda environment:    <pre><code>conda create -n gridfit-dev -c conda-forge python=3.10 cmake make gxx_linux-64 -y\nconda activate gridfit-dev\nconda install -c conda-forge pybind11 pytest numpy scipy -y\nRscript -e 'install.packages(\"devtools\")'\n</code></pre></li> <li>Install the Python package in editable mode:    <pre><code>python -m pip install -e .\n</code></pre></li> <li>Build the C++ core and R package as needed (see CMakeLists.txt and R/README).</li> </ol>"},{"location":"development/#manual-testing-before-push","title":"Manual Testing Before Push","text":""},{"location":"development/#python","title":"Python","text":"<p>Run the integration tests with pytest: <pre><code>pytest tests/python\n</code></pre></p>"},{"location":"development/#r","title":"R","text":"<p>Run the R integration test script: <pre><code>Rscript tests/R/test_interp.R\n</code></pre></p> <p>Make sure both tests pass before pushing changes.</p>"},{"location":"development/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>This project uses pre-commit hooks to help maintain code quality for Python and C++ files. Hooks will automatically check formatting and linting before each commit.</p>"},{"location":"development/#setup","title":"Setup","text":"<ol> <li>Install pre-commit (if not already):    <pre><code>python -m pip install pre-commit\n</code></pre></li> <li>Install the hooks:    <pre><code>pre-commit install\n</code></pre></li> </ol> <p>Now, every time you commit, black and flake8 will check Python files, and clang-format will check C++ files. You can add more hooks or languages as needed.</p>"},{"location":"dev/new_class/","title":"Adding a New C++ Class to gridfit with pybind11","text":""},{"location":"dev/new_class/#step-by-step-guide","title":"Step-by-step Guide","text":""},{"location":"dev/new_class/#1-create-the-header-file","title":"1. Create the Header File","text":"<p>File: <code>include/your_class.h</code> <pre><code>#pragma once\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nclass YourClass {\nprivate:\n    // Private member variables\n    std::vector&lt;float&gt; data_;\n\npublic:\n    // Constructor\n    YourClass();\n\n    // Methods\n    std::string details();\n    void someMethod(int param);\n};\n</code></pre></p>"},{"location":"dev/new_class/#2-create-the-implementation-file","title":"2. Create the Implementation File","text":"<p>File: <code>src/your_class.cpp</code> <pre><code>#include \"your_class.h\"\n\nYourClass::YourClass() {\n    // Constructor implementation\n}\n\nstd::string YourClass::details() {\n    return \"Implementation here\";\n}\n\nvoid YourClass::someMethod(int param) {\n    // Method implementation\n}\n</code></pre></p>"},{"location":"dev/new_class/#3-update-the-python-bindings","title":"3. Update the Python Bindings","text":"<p>File: <code>python/gridfit/interp_py.cpp</code></p> <p>Add include at top: <pre><code>#include \"../include/your_class.h\"\n</code></pre></p> <p>Add to <code>PYBIND11_MODULE</code> section: <pre><code>PYBIND11_MODULE(gridfit_interp, m) {\n    // ... existing bindings ...\n\n    // Bind your new class\n    py::class_&lt;YourClass&gt;(m, \"YourClass\")\n        .def(py::init&lt;&gt;())                          // Constructor with no args\n        .def(\"details\", &amp;YourClass::details)        // Bind method\n        .def(\"some_method\", &amp;YourClass::someMethod, // Bind method with args\n             py::arg(\"param\"));\n}\n</code></pre></p>"},{"location":"dev/new_class/#4-update-setuppy","title":"4. Update setup.py","text":"<p>File: <code>setup.py</code></p> <p>Add the new source file to the sources list: <pre><code>ext_modules = [\n    Pybind11Extension(\n        \"gridfit.gridfit_interp\",\n        sources=[\n            \"python/gridfit/interp_py.cpp\", \n            \"src/interp.cpp\",\n            \"src/your_class.cpp\"  # ADD THIS\n        ],\n        include_dirs=[\"include\"],\n        language=\"c++\",\n        cxx_std=11,\n    ),\n]\n</code></pre></p>"},{"location":"dev/new_class/#5-update-python-package-init","title":"5. Update Python Package Init","text":"<p>File: <code>python/gridfit/__init__.py</code></p> <p>Expose the class to Python users: <pre><code>from .gridfit_interp import YourClass\n</code></pre></p>"},{"location":"dev/new_class/#6-build-and-install","title":"6. Build and Install","text":"<pre><code># Clean previous build\nrm -rf build/\n\n# Reinstall\npip install -e .\n</code></pre>"},{"location":"dev/new_class/#7-test-from-python","title":"7. Test from Python","text":"<pre><code>from gridfit import YourClass\n\nobj = YourClass()\nprint(obj.details())\n</code></pre>"},{"location":"dev/new_class/#common-patterns","title":"Common Patterns","text":""},{"location":"dev/new_class/#constructor-with-parameters","title":"Constructor with Parameters","text":"<pre><code>// C++ header\nYourClass(int size, double value);\n\n// pybind11 binding\n.def(py::init&lt;int, double&gt;(),\n     py::arg(\"size\"), py::arg(\"value\"))\n</code></pre>"},{"location":"dev/new_class/#method-returning-numpy-array","title":"Method Returning NumPy Array","text":"<pre><code>// C++ method\nstd::vector&lt;float&gt; getData();\n\n// pybind11 binding\n.def(\"get_data\", [](YourClass&amp; self) {\n    std::vector&lt;float&gt; data = self.getData();\n    return py::array_t&lt;float&gt;(data.size(), data.data());\n})\n</code></pre>"},{"location":"dev/new_class/#method-taking-numpy-array","title":"Method Taking NumPy Array","text":"<pre><code>// C++ wrapper in interp_py.cpp\nvoid setData_wrapper(YourClass&amp; self, py::array_t&lt;float&gt; arr) {\n    auto buf = arr.request();\n    std::vector&lt;float&gt; vec(static_cast&lt;float*&gt;(buf.ptr),\n                           static_cast&lt;float*&gt;(buf.ptr) + buf.size);\n    self.setData(vec);\n}\n\n// pybind11 binding\n.def(\"set_data\", &amp;setData_wrapper)\n</code></pre>"},{"location":"dev/new_class/#checklist","title":"Checklist","text":"<ul> <li> Created <code>include/your_class.h</code></li> <li> Created <code>src/your_class.cpp</code></li> <li> Added <code>#include</code> to <code>interp_py.cpp</code></li> <li> Added <code>py::class_&lt;&gt;</code> binding to <code>PYBIND11_MODULE</code></li> <li> Added source file to <code>setup.py</code></li> <li> Exposed class in <code>__init__.py</code></li> <li> Rebuilt with <code>pip install -e .</code></li> <li> Tested from Python</li> </ul>"},{"location":"dev/new_class/#troubleshooting","title":"Troubleshooting","text":"<p>\"undefined symbol\" error: - Check that <code>.cpp</code> file is in <code>setup.py</code> sources - Rebuild with <code>rm -rf build/ &amp;&amp; pip install -e .</code></p> <p>\"cannot import name\" error: - Check class is exposed in <code>__init__.py</code> - Check binding name matches: <code>py::class_&lt;YourClass&gt;(m, \"YourClass\")</code></p> <p>Build errors: - Check all includes are correct - Check <code>#pragma once</code> in header - Check constructor/method signatures match between <code>.h</code> and <code>.cpp</code></p>"}]}